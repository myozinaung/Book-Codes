from Control_MYO.Helpers import clamp, pi2pi

# Inntegrator Backsetpping Autopilot

# Nomoto1st [FL + SF]
class IBS(object):
    # Constructor
    def __init__(self, K, T, k1, k2, u_bounds):
        self.K = K
        self.T = T
        self.k1 = k1
        self.k2 = k2
        
        self.u_min = u_bounds[0]
        self.u_max = u_bounds[1]
        print("Linear IBS object created!")
    def __call__(self, x, x_d):

        f1 = 0
        f2 = (-1/self.T)*x[1]

        x_dot1 = -self.k1*(x[0] - x_d[0]) # SF
        x_bar2 =  x_dot1 - f1 # FL

        x_dot2 = -self.k2*(x[1] - x_bar2) # SF
        u      =  x_dot2 - f2 # FL
        delta = (self.T/self.K)*u

        delta = clamp(delta, self.u_min, self.u_max)
        return delta

# Nomoto1stNL
class IBS_NL(object):
    # Constructor
    def __init__(self, K, T, k1, k2, u_bounds):
        self.K = K
        self.T = T
        self.k1 = k1
        self.k2 = k2
        
        self.u_min = u_bounds[0]
        self.u_max = u_bounds[1]
        print("Nonlinear IBS object created!")
    def __call__(self, x, x_d):

        n1 = -1.25
        n3 = 3

        f1 = 0
        f2 = (-1/self.T)*(n3*x[1]**3 + n1*x[1])
    
        x_dot1 = -self.k1*(x[0] - x_d[0])
        x_bar2 =  x_dot1 - f1

        x_dot2 = -self.k2*(x[1] - x_bar2)
        u      =  x_dot2 - f2
        delta = (self.T/self.K)*u

        delta = clamp(delta, self.u_min, self.u_max)
        return delta

# Nomoto1stNL with Rudder Dynamics
class IBS_NL_RudDyn(object):
    # Constructor
    def __init__(self, K, T, T_delta, k1, k2, k3, u_bounds):
        self.K = K
        self.T = T
        self.T_delta = T_delta
        self.k1 = k1
        self.k2 = k2
        self.k3 = k3
        
        self.u_min = u_bounds[0]
        self.u_max = u_bounds[1]
        print("Nonlinear IBS with Rudder Dynamics object created!")
    def __call__(self, x, x_d):

        n1 = -1.25
        n3 = 3

        f1 = 0
        f2 = 0
        f3 = (-1/(self.T*self.T_delta))*((self.T+self.T_delta)*x[2] + n3*x[1]**3 + n1*x[1])
    
        x_dot1 = -self.k1*(x[0] - x_d[0])
        x_bar2 =  x_dot1 - f1

        x_dot2 = -self.k2*(x[1] - x_bar2)
        x_bar3 =  x_dot2 - f2

        x_dot3 = -self.k3*(x[2] - x_bar3)
        u      =  x_dot3 - f3
        
        delta = (self.T*self.T_delta/self.K)*u

        delta = clamp(delta, self.u_min, self.u_max)
        return delta

# Nomoto1stNL Lyapunov Stabilization Function-based
class IBS_NL_LPN(object):
    # Constructor
    def __init__(self, K, T, k1, k2, u_bounds):
        self.K = K
        self.T = T
        self.k1 = k1
        self.k2 = k2
        
        self.u_min = u_bounds[0]
        self.u_max = u_bounds[1]
        print("Nonlinear Lyapunov-based IBS object created!")
    def __call__(self, x, x_d):
        # x_d[1] = 0 # This two can't be zers, they have to generated by RefGen
        # x_d[2] = 0
        
        n1 = -1.25
        n3 = 3

        f1 = 0
        f1_dot = 0
        f2 = (-1/self.T)*(n3*x[1]**3 + n1*x[1])
        g  = self.K/self.T
    
        z1 = x[0] - x_d[0]
        alpha1 = -self.k1*z1 - f1 + x_d[1]
        z2 = x[1] - alpha1

        gu = -z1*(1+self.k1**2) + z2*(self.k1-self.k2) - f2 + self.k1*f1 - f1_dot + x_d[2]

        delta = (1/g)*gu

        delta = clamp(delta, self.u_min, self.u_max)
        return delta

# Nomoto1stNL Lyapunov Stabilization Function-based
class IBS_NL_LPN_RudDyn1(object): # Anna Paper
    # Constructor
    def __init__(self, K, T, KR, TR, k1, k2, k3, u_bounds):
        self.K = K
        self.T = T
        self.KR = KR
        self.TR = TR

        self.k1 = k1
        self.k2 = k2
        self.k3 = k3
        
        self.u_min = u_bounds[0]
        self.u_max = u_bounds[1]
        print("Nonlinear Lyapunov-based IBS with Ruuder Dynamics object created!")
    def __call__(self, x, x_d):
        # Need x_d[3]: psi_dddot
        # Need x[2]: Rudder Sate, State Func needs rudder state
        
        n1 = -1.25
        n3 = 3

        f1      = 0
        # x1_dot  = f1 + x[1]
        f1_dot  = 0
        f1_ddot = 0

        f2 = (-1/self.T)*(n3*x[1]**3 + n1*x[1])
        # f2 = (-1/self.T)*(n3*x[1]**3 + n1*x[1]) + (self.K/self.T)*x[2] - x[2]
        x2_dot = f2 + x[2]
        f2_dot = (-1/self.T)*(3*n3*x[1]**2*x2_dot + n1*x2_dot)

        f3 = (-1/self.TR)*x[2]
        # f3 = (-1/self.TR)*x[2] * (self.T/self.K)
        g  = self.KR/self.TR
        # g  = self.KR/self.TR * (self.T/self.K)
    
        z1         = x[0] - x_d[0]
        z1_dot     = f1 + x[1] + x_d[1]
        alpha1     = -self.k1*z1 - f1 + x_d[1]
        alpha1_dot = -self.k1*z1_dot - f1_dot - x_d[2]

        z2         = x[1] - alpha1
        z2_dot     = f2 + x[2] - alpha1_dot
        alpha2     = -self.k2*z2 - z1 - f2 - self.k1*(f1+z2+alpha1+x_d[1]) - f1_dot - x_d[2]
        alpha2_dot = -self.k2*z2_dot - z1_dot - f2_dot - self.k1*(f1_dot+z2_dot+alpha1_dot+x_d[2]) - f1_ddot - x_d[3]

        z3         = x[2] - alpha2
        gu         = -self.k3*z3 - z2 - f3 + alpha2_dot
        delta      = (1/g)*gu
        delta      = clamp(delta, self.u_min, self.u_max)
        return delta

# Nomoto1stNL Lyapunov Stabilization Function-based
class IBS_NL_LPN_RudDyn2(object): # Anna Paper
    # Constructor
    def __init__(self, K, T, KR, TR, k1, k2, k3, u_bounds):
        self.K = K
        self.T = T
        self.KR = KR
        self.TR = TR

        self.k1 = k1
        self.k2 = k2
        self.k3 = k3
        
        self.u_min = u_bounds[0]
        self.u_max = u_bounds[1]
        print("Nonlinear Lyapunov-based IBS with Ruuder Dynamics object created!")
    def __call__(self, x, x_d):
        # Need x_d[3]: psi_dddot
        # Need x[2]: Rudder Sate, State Func needs rudder state
        
        n1 = -1.25
        n3 = 3
        h  = n3*x[1]**3 + n1*x[1]

        f1      = 0
        # x1_dot  = f1 + x[1]
        f1_dot  = 0
        f1_ddot = 0

        f2 = 0
        # x2_dot = f2 + x[2]
        f2_dot = 0

        f3 = (-1/(self.T*self.TR))*((self.T+self.TR)*x[2] + h)
        g  = self.K/(self.T*self.TR)
    
        z1         = x[0] - x_d[0]
        z1_dot     = f1 + x[1] + x_d[1]
        alpha1     = -self.k1*z1 - f1 + x_d[1]
        alpha1_dot = -self.k1*z1_dot - f1_dot - x_d[2]

        z2         = x[1] - alpha1
        z2_dot     = f2 + x[2] - alpha1_dot
        alpha2     = -self.k2*z2 - z1 - f2 - self.k1*(f1+z2+alpha1+x_d[1]) - f1_dot - x_d[2]
        alpha2_dot = -self.k2*z2_dot - z1_dot - f2_dot - self.k1*(f1_dot+z2_dot+alpha1_dot+x_d[2]) - f1_ddot - x_d[3]

        z3         = x[2] - alpha2
        gu         = -self.k3*z3 - z2 - f3 + alpha2_dot
        delta      = (1/g)*gu
        delta      = clamp(delta, self.u_min, self.u_max)
        return delta